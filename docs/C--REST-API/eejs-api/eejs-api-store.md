# `eejs.api.store`

This is built by the eejs.api.init function and exposed when the promise resolves.   It is a Vuex store instance which you can [read more about here](https://vuex.vuejs.org/en/).  The primary purposes for this vuex store are:

1. Maintain/manage state for all registered EE collections.
2. Expose custom mutation, getter, and action methods for interacting with and managing EE entities for registered collections.
3. Take care of all interactions with the REST API using the bundled [vue-resource](https://github.com/pagekit/vue-resource) library.
4. Tracking changes made to entities in the state.

The various registered methods in build component options for the registered collections are already setup to interact with the `eejs.api.store`.  However its also exposed publicly if you want to add it to any custom components built in your app.

## Basic Structure

`eejs.api.store` is built via `eejs.api.init` via the `eejs.api.main` object. 

### Main Store

The main store object consists of state, modules, getters, mutations and actions properties (in keeping with what the vuex options array accepts).

#### `state`

Property | Description
|--------|------------|
restRoute | The value for this state property is the base path for the rest endpoints. All calls to rest endpoints will use this as the base for the url used.

#### `modules`

Registered collections are registered as modules on the main store state.  You can read more about [vuex modules here](https://vuex.vuejs.org/en/modules.html).  More on the collection modules are found later in this document.

#### `getters`

There are a number of global getters that are found in the main store.  All getters _only_ work with what is in the store state and do not make any calls to the server via the REST API. Thus all these methods are synchronous.

Method | Arguments | Purpose & Example Usage (outside of vue instance)
|-------|-------|---------------------|
`hasEntityInCollection` | *collection, entity* | Used to find out whether the given entity object exists in the state for the given collection. Returns a boolean. Note, the entity object does not have to be the full object as long as the primary key is present.<br><br>**Example:**<br><br>`eejs.api.store.getters.hasEntityInCollection('events',{EVT_ID:10})`
`isNewEntity` | *entityId* | This is a helper method that simply returns whether the given entityId represents a new entity or not in the store state.  In this library, new entities have a string that is a combination of `_new_id_` and a unique id generated by the library.  "New Entities" are entities that have not been persisted to the server yet and exist only in the client.<br><br>**Example:**<br><br>`eejs.api.store.getters.isNewEntity('_new_id_56')`
`getEntityForId` | *collection, entityId* | With the given collection and entityId, this will return the entity if it exists in the collection state.  Note, this does *not* attempt to retrieve the entity from the server for that you use the `fetchEntityById` action.<br><br>**Example:**<br><br>`eejs.api.store.getters.getEntityForId('events', 10);`
`getFieldValueFromEntityById` | *collection, entityId, field* | This retrieves the value for a specific field of a specific entity in a collection stored in the store state.<br><br>**Example:**<br><br>`eejs.api.store.getters.getFieldValueFromEntityById('events',10,'EVT_name')`
`getCollectionEndpoint` | *collection* | Retrieves the base endpoint for the given collection (if the collection is registered).<br><br>**Example:**<br><br>`eejs.api.store.getters.getCollectionEndpoint('events');`


#### `mutations`

In Vuex, any mutations of the state must be done via the vuex commit method invoking a registered mutation. This maintains the integrity of the state.  In this library, all the mutations not only affect the store state but also maintains the changeMap for each collection (more on that later). As with getters, all calls to mutations are synchronous.

Each mutation call expects a payload object. The properties within the object are listed in the table.

Mutation | Payload Object | Purpose & Example Usage (outside the Vue instance)
|-------|----------|-----------------------------|
`updateEntityById` | {*collection*, *entity*} | This updates an entity in the given collection matching the incoming entities ID.<br><br>**Example Usage:**<br><br> `eejs.api.store.commit('updateEntityById', { collection : 'events', entity : { EVT_ID : 11, EVT_name : 'Replacing Event Title' }});`
`addEntity` | {*collection*, *entity*, *refresh*, *fromDb*} | This is used to add a complete entity to the specific collection in the state.  The optional *refresh* argument defaults to false, but if its true, then any existing entity values are replaced.  Otherwise if the entity already exists it will not be replace.  The optional *fromDb* argument which defaults to false is used to indicate that the entity being added comes from a db (or server) call when set to true.  This has implications for how/when the changeMap is updated.  The changeMap does not have ANY changes recorded for entities that are added to the state from the db.<br><br>**Example:**<br><br>`eejs.api.store.commit('addEntity', { collection : 'events', entity : { EVT_ID : 10, EVT_name : 'Adding an Event' }});`
`addRelationsForEntity` | {*collection*, *collectionEntityId*, *relation*, *relationEntityId*, *doStoreCheck*} | Used to connect related items by ID in the store for the given values.<br><br> **Note:** in general this mutation should not be committed directly because it only adds the relation one way. It's better to add relations using the `addRelation` _action_ because it will take care of recursively committing relations both ways.<br><br>  There is an optional `doStoreCheck` property that can be included in the `payload` object. It defaults to true.  When true an exception is thrown if any of the passed in collections are not registered in the store state. When false, an exception is not thrown but the relation won't get added for non-registered collections.<br><br>**Example:**<br><br>`eejs.api.store.commit('addRelationsForEntity', { collection: 'events', collectionEntityId: 10, relation : 'datetimes', relationEntityId : 23 })`
  

#### `actions`

Instead of mutating the state, actions commit mutations. Actions are also used when there are things you need to do that may be asynchronous in nature. All usage of the vue-resource libary to make calls to the server via the REST API endpoints are done via actions.  This is important because in Vuex, mutations _cannot_ be asynchronous.  

As with mutations, actions receive a payload object that has various named properties depending on the action.  The payload object is represented in the payload column in the below table.

With vuex, actions are invoked via a call to the vuex `dispatch` method.

Action | Payload Object | Purpose & Example Usage (outside the Vue instance) | Returns Promise?
|-------------|-------------|-----|----------------------------------|
`fetchCollection` | {*collection*, *queryString*, *refresh*} | This retrieves entities from the REST API for the given collection and then commits them to the state for that collection.  An optional queryString object filtering what entities get returned can be included in the payload object.  The queryString object should be in a format that is accepted by the URI.js library. Another optional payload property is `refresh`, this defaults to false, but when true, if any of the results from the fetch match an existing entity in the collection state, they will be replaced.<br><br>**Example:**<br><br>`eejs.api.store.dispatch('fetchCollection', { collection: 'events'}).then( function(response) { //do stuff } );` | yes
`fetchRelatedForEntity` | {*collection*, *entityId*, *relation*, *refresh*} | This fetches the related entities for the given entity.  For example, you'd use this if you wanted to get all the related datetimes for a given event.  The optional `refresh` property on the payload object will always use the REST API is to retrieve the relations for the entity when true and replaces what is already in the store state.  When false, it only hits the REST API to retrieve relations if there are none found in the store state for that entity.<br><br>**Example:**<br><br> `eejs.api.store.dispatch('fetchRelatedForEntity', { collection: 'events', 'entityId': 10, relation: 'datetimes'}).then( function(response) { //do stuff } );` | yes
`fetchEntityById` | {*collection*, *entityId*} | Fetches a specific entity for the given collection using the value given for its primary key. This will retrieve the entity from the entity from the collection state if present, otherwise it will use the REST API to grab the entity.<br><br>**Example:**<br><br>`eejs.api.store.dispatch('fetchEntityById', { collection: 'events', 'entityId': 10}).then( function(response) { //do stuff } );` | yes
`addRelationByIds` | {*collection*, *collectionEntityId*, *relation*, *relationEntityId*} | This is similar to the `addRelationsForEntity` mutation except this handles adding the relations in the reverse as well. The `relationEntityId` property can be an array of relation ids for the `relation` collection.<br><br>**Example:**<br><br>`eejs.api.store.dispatch('addRelationByIds', { collection: 'events', 'collectionEntityId': 10, relation: 'datetimes', relationEntityId : [ 22, 23, 24 ] });` | no


### Collection Modules

The eejs.api.main object builds a vuex module using each registered collection for the `eejs.api.store`. This is then registered with the `eejs.api.store` object.  Currently the only property on collection modules is the `state`.  This is where various information about the collection is preserved.

#### `state`

state properties | Description |
| --------------- | ------------- |
entities | This holds an array of entities belonging to this collection as they are added to the state.
relations | This is an object used to represent all the relations between entities in this collection and entities in other collections. It is stored in the format:<br><br>```relations: {'datetimes' : { 236 : [12,34,41]}}```<br><br> So it is an object where the key is the string referencing the relation collection name. The value is another object where keys are the ids of the main collection entities, and the values are an array of relation ids.  So in our example this means that for the Event with the id of 236, there are three datetime relations to that even with the ids 12, 34, and 41. **Note**: Even if the relation for this collection is one to one, the ids for the relation will still be within an array.
primaryKey | This is a handy reference to the primaryKey field name for the collection. Example: for `events` this would be `EVT_ID`.
allowedProperties | This sets the values from the `properties` object returned with the JSON Schema object returned from the REST API when the collection was registered.  This can be used to validate incoming field values before they get added to the state.
 collectionEndpoint | This is a reference to the REST API endpoint for this collection resource.
 _links | This is a reference to all the `_links` returned in the response for this collection.
 _calculated_fields | This is a reference to all the `_calculated_fiedls` returned in the response for the collection.
 changeMap | The changeMap is where the `eejs.api.store` keeps track of all changes for the collection. See the table for all the properties on the changeMap below.
 
**ChangeMap properties**

In the changemap tracked by `eejs.api.store`, ids are only found once in the various changeMap objects.  For instance, if an Event entity is updated, it gets added to the `update` property in the `changeMap` for the `events` collection state.  However, if it later is marked for `delete` then it's id gets removed from the `update` property and added to the `delete` property.
 
property | description
|--------|-------------|
create | A simple array of ids for entities in the collection state that were created by the client (and don't exist yet in the server).<br><br>**Example format:**</br><br> `{ create : [ 10, 11, 12 ] }`
update | A simple array of ids for entities that were changed by the client after the initial fetch from the server. <br><br>**Example format:**</br><br> `{ update : [ 12 ] }`
delete | A simple array of ids for entities that the client has marked for deletion on the server. <br><br>**Example format:**</br><br> `{ delete : [ 15 ] }`
relations | This property has an object as its value that holds a changeMap of relations for this entity.  The object has relation collection names as the keys, then the value of those is an object with the keys `addd` and `removed` and the values of those are an object where the keys are the ids for entities in this collection and the values are a simple array of relations that were added or removed for that entity. In the example given, if the collection this changeMap belonged to is an event, then this means that for the event entity with the id of 12, it had a relation created for datetimes with the ids 23, and 24.  For the event entity with the id of 56, it had its relations with the datetimes having ids of 33 and 34 removed. <br><br>**Example format:**</br><br> `{ relations : { 'datetimes : { added : { 12 : [ 23, 24 ] }, removed : { 56 : [ 33, 34 ] } } } }`


### Extra Methods added to vuex prototype.
 
There are various methods that were added to the vuex prototype to make certain repeated actions more DRY.

> Note: all of these methods should only be called from within a mutation and not directly.

Method | Arguments | Description
|--------|------------|---------------|
`replaceEntityInCollection` | *collection, entity* | This is called to replace an entity in a collection in the store state.
`commitChangeRecord` | *collection, entity, changeType* | This is used to commit a change record to the changeMap for the given collection.
`removeChangeRecord` | *collection, entityId, changeType* | This is used to remove a change record from the changeMap for the given collection and entity. 
`commitRelatedChangeRecord` | *collection, relation, entityId, relatedEntityId, changeType, recursive* | This is used to commit a change record to the change map for the given collection for a relation on the given entity.  The `recursive` argument is optional, defaults to true, and is used to indicate whether the changeRecord should be recorded on the relations changeMap as well.
`removeRelatedChangeRecord` | *collection, relation, entityId, relatedEntityId, changeType, recursive* | This is similar to `commitRelatedChangeRecord` except it removes relation from the changeMap record.
`removeAllRelatedChangeRecords` | *collection, entityId, recursive* | This is a method for rapidly removing all change records in the change maps for the given entity.  By default, it is recursive which means it will in turn ensure that the corresponding changeMap in any registered relations have the entity ids removed.
`commitRelationsForEntity` | *collection, collectionEntityId, relation, relationEntityId, doStoreCheck, fromDb* | Used to conect related items by ID in the store for all affected relations.
 `commitEntityToCollection` | *collection, entity, refresh, fromDb* | Commits an entity to its collection state.

